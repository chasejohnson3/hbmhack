# -*- coding: utf-8 -*-
"""Autogenerated file - DO NOT EDIT
If you spot a bug, please report it on the mailing list and/or change the generator."""

import pydra
from pydra.engine import specs
import attr


input_fields = [
    (
        "InputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Volume containing the input grayscale data.",
                "position": -2
            }
        ),
    ),
    (
        "OutputGeometry", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Output that contains geometry model.",
                "position": -1
            }
        ),
    ),
    (
        "threshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--threshold %f",
                "help_string": "Grayscale threshold of isosurface. The resulting surface of triangles separates the volume into voxels that lie above (inside) and below (outside) the threshold."
            }
        ),
    ),
    (
        "name", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--name %s",
                "help_string": "Name to use for this model."
            }
        ),
    ),
    (
        "smooth", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--smooth %d",
                "help_string": "Number of smoothing iterations. If 0, no smoothing will be done."
            }
        ),
    ),
    (
        "decimate", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--decimate %f",
                "help_string": "Target reduction during decimation, as a decimal percentage reduction in the number of polygons. If 0, no decimation will be done."
            }
        ),
    ),
    (
        "splitnormals", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--splitnormals ",
                "help_string": "Splitting normals is useful for visualizing sharp features. However it creates holes in surfaces which affect measurements"
            }
        ),
    ),
    (
        "pointnormals", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--pointnormals ",
                "help_string": "Calculate the point normals? Calculated point normals make the surface appear smooth. Without point normals, the surface will appear faceted."
            }
        ),
    ),
    (
        "debug", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--debug ",
                "help_string": "Turn this flag on to log more details during execution."
            }
        ),
    ),
]

output_fields = [
    (
        "OutputGeometry", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output that contains geometry model.",
                "position": -1,
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

GrayscaleModelMaker_task = pydra.ShellCommandTask(
    name="GrayscaleModelMaker",
    executable=" GrayscaleModelMaker ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "labelToSmooth", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--labelToSmooth %d",
                "help_string": "The label to smooth.  All others will be ignored.  If no label is selected by the user, the maximum label in the image is chosen by default."
            }
        ),
    ),
    (
        "numberOfIterations", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfIterations %d",
                "help_string": "The number of iterations of the level set AntiAliasing algorithm"
            }
        ),
    ),
    (
        "maxRMSError", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maxRMSError %f",
                "help_string": "The maximum RMS error."
            }
        ),
    ),
    (
        "gaussianSigma", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--gaussianSigma %f",
                "help_string": "The standard deviation of the Gaussian kernel"
            }
        ),
    ),
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Input label map to smooth",
                "position": -2
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Smoothed label map",
                "position": -1
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Smoothed label map",
                "position": -1,
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

LabelMapSmoothing_task = pydra.ShellCommandTask(
    name="LabelMapSmoothing",
    executable=" LabelMapSmoothing ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "Model1", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Input model 1",
                "position": -3
            }
        ),
    ),
    (
        "Model2", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Input model 2",
                "position": -2
            }
        ),
    ),
    (
        "ModelOutput", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Output model",
                "position": -1
            }
        ),
    ),
]

output_fields = [
    (
        "ModelOutput", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output model",
                "position": -1,
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

MergeModels_task = pydra.ShellCommandTask(
    name="MergeModels",
    executable=" MergeModels ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "InputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Input label map. The Input Volume drop down menu is populated with the label map volumes that are present in the scene, select one from which to generate models.",
                "position": -1
            }
        ),
    ),
    (
        "color", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--color %s",
                "help_string": "Color table to make labels to colors and objects"
            }
        ),
    ),
    (
        "modelSceneFile", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--modelSceneFile %s...",
                "help_string": "Generated models, under a model hierarchy node. Models are imported into Slicer under a model hierarchy node, and their colors are set by the color table associated with the input label map volume. The model hierarchy node must be created before running the model maker, by selecting Create New ModelHierarchy from the Models drop down menu. If you're running from the command line, a model hierarchy node in a new mrml scene will be created for you."
            }
        ),
    ),
    (
        "name", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--name %s",
                "help_string": "Name to use for this model. Any text entered in the entry box will be the starting string for the created model file names. The label number and the color name will also be part of the file name. If making multiple models, use this as a prefix to the label and color name."
            }
        ),
    ),
    (
        "generateAll", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--generateAll ",
                "help_string": "Generate models for all labels in the input volume. select this option if you want to create all models that correspond to all values in a labelmap volume (using the Joint Smoothing option below is useful with this option). Ignores Labels, Start Label, End Label settings. Skips label 0."
            }
        ),
    ),
    (
        "labels", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--labels %s",
                "help_string": "A comma separated list of label values from which to make models. f you specify a list of Labels, it will override any start/end label settings. If you click Generate All Models it will override the list of labels and any start/end label settings."
            }
        ),
    ),
    (
        "start", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--start %d",
                "help_string": "If you want to specify a continuous range of labels from which to generate models, enter the lower label here. Voxel value from which to start making models. Used instead of the label list to specify a range (make sure the label list is empty or it will over ride this)."
            }
        ),
    ),
    (
        "end", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--end %d",
                "help_string": "If you want to specify a continuous range of labels from which to generate models, enter the higher label here. Voxel value up to which to continue making models. Skip any values with zero voxels."
            }
        ),
    ),
    (
        "skipUnNamed", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--skipUnNamed ",
                "help_string": "Select this to not generate models from labels that do not have names defined in the color look up table associated with the input label map. If true, only models which have an entry in the color table will be generated.  If false, generate all models that exist within the label range."
            }
        ),
    ),
    (
        "jointsmooth", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--jointsmooth ",
                "help_string": "This will ensure that all resulting models fit together smoothly, like jigsaw puzzle pieces. Otherwise the models will be smoothed independently and may overlap."
            }
        ),
    ),
    (
        "smooth", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--smooth %d",
                "help_string": "Here you can set the number of smoothing iterations for Laplacian smoothing, or the degree of the polynomial approximating the windowed Sinc function. Use 0 if you wish no smoothing. "
            }
        ),
    ),
    (
        "filtertype", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--filtertype %s",
                "help_string": "You can control the type of smoothing done on the models by selecting a filter type of either Sinc or Laplacian."
            }
        ),
    ),
    (
        "decimate", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--decimate %f",
                "help_string": "Chose the target reduction in number of polygons as a decimal percentage (between 0 and 1) of the number of polygons. Specifies the percentage of triangles to be removed. For example, 0.1 means 10% reduction and 0.9 means 90% reduction."
            }
        ),
    ),
    (
        "splitnormals", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--splitnormals ",
                "help_string": "Splitting normals is useful for visualizing sharp features. However it creates holes in surfaces which affects measurements."
            }
        ),
    ),
    (
        "pointnormals", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--pointnormals ",
                "help_string": "Turn this flag on if you wish to calculate the normal vectors for the points."
            }
        ),
    ),
    (
        "pad", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--pad ",
                "help_string": "Pad the input volume with zero value voxels on all 6 faces in order to ensure the production of closed surfaces. Sets the origin translation and extent translation so that the models still line up with the unpadded input volume."
            }
        ),
    ),
    (
        "modelHierarchyFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--modelHierarchyFile %s",
                "help_string": "A mrml file that contains a template model hierarchy tree with a hierarchy node per color used in the input volume's color table. Color names used for the models are matched to template hierarchy names to create a multi level output tree. Create a hierarchy in the Models GUI and save a scene, then clean it up to remove everything but the model hierarchy and display nodes."
            }
        ),
    ),
    (
        "saveIntermediateModels", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--saveIntermediateModels ",
                "help_string": "You can save a copy of the models after each of the intermediate steps (marching cubes, smoothing, and decimation if not joint smoothing, otherwise just after decimation). These intermediate models are not saved in the mrml file, you have to load them manually after turning off deleting temporary files in they python console (View ->Python Interactor) using the following command slicer.modules.modelmaker.cliModuleLogic().DeleteTemporaryFilesOff()."
            }
        ),
    ),
    (
        "debug", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--debug ",
                "help_string": "turn this flag on in order to see debugging output (look in the Error Log window that is accessed via the View menu)"
            }
        ),
    ),
]

output_fields = [
    (
        "modelSceneFile", 
        attr.ib(
            type=OutputMultiPath,
            metadata={
                "help_string": "Generated models, under a model hierarchy node. Models are imported into Slicer under a model hierarchy node, and their colors are set by the color table associated with the input label map volume. The model hierarchy node must be created before running the model maker, by selecting Create New ModelHierarchy from the Models drop down menu. If you're running from the command line, a model hierarchy node in a new mrml scene will be created for you.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

ModelMaker_task = pydra.ShellCommandTask(
    name="ModelMaker",
    executable=" ModelMaker ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "labelValue", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--labelValue %d",
                "help_string": "The unsigned char label value to use in the output label map."
            }
        ),
    ),
    (
        "InputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Output volume will have the same origin, spacing, axis directions, and extent as this volume.",
                "position": -3
            }
        ),
    ),
    (
        "surface", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Input model",
                "position": -2
            }
        ),
    ),
    (
        "OutputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Unsigned char label map volume",
                "position": -1
            }
        ),
    ),
]

output_fields = [
    (
        "OutputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Unsigned char label map volume",
                "position": -1,
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

ModelToLabelMap_task = pydra.ShellCommandTask(
    name="ModelToLabelMap",
    executable=" ModelToLabelMap ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "InputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Volume to use to 'paint' the model",
                "position": -3
            }
        ),
    ),
    (
        "InputModel", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Input model",
                "position": -2
            }
        ),
    ),
    (
        "OutputModel", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Output 'painted' model",
                "position": -1
            }
        ),
    ),
]

output_fields = [
    (
        "OutputModel", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output 'painted' model",
                "position": -1,
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

ProbeVolumeWithModel_task = pydra.ShellCommandTask(
    name="ProbeVolumeWithModel",
    executable=" ProbeVolumeWithModel ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)