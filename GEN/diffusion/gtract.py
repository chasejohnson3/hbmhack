# -*- coding: utf-8 -*-
"""Autogenerated file - DO NOT EDIT
If you spot a bug, please report it on the mailing list and/or change the generator."""

import pydra
from pydra.engine import specs
import attr


input_fields = [
    (
        "testFiber", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--testFiber %s",
                "help_string": "Required: test fiber tract file name"
            }
        ),
    ),
    (
        "standardFiber", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--standardFiber %s",
                "help_string": "Required: standard fiber tract file name"
            }
        ),
    ),
    (
        "closeness", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--closeness %f",
                "help_string": "Closeness of every test fiber to some fiber in the standard tract, computed as a sum of squares of spatial differences of standard points"
            }
        ),
    ),
    (
        "numberOfPoints", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfPoints %d",
                "help_string": "Number of points in comparison fiber pairs"
            }
        ),
    ),
    (
        "testForBijection", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--testForBijection ",
                "help_string": "Flag to apply the closeness criterion both ways"
            }
        ),
    ),
    (
        "testForFiberCardinality", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--testForFiberCardinality ",
                "help_string": "Flag to require the same number of fibers in both tracts"
            }
        ),
    ),
    (
        "writeXMLPolyDataFile", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--writeXMLPolyDataFile ",
                "help_string": "Flag to make use of XML files when reading and writing vtkPolyData."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))


compareTractInclusion_task = pydra.ShellCommandTask(
    name="compareTractInclusion",
    executable=" compareTractInclusion ", 
    input_spec=input_spec_pdr,
    
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input file containing the vector that will be extracted"
            }
        ),
    ),
    (
        "vectorIndex", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--vectorIndex %d",
                "help_string": "Index in the vector image to extract"
            }
        ),
    ),
    (
        "setImageOrientation", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--setImageOrientation %s",
                "help_string": "Sets the image orientation of the extracted vector (Axial, Coronal, Sagittal)"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing the vector image at the given index"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing the vector image at the given index",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

extractNrrdVectorIndex_task = pydra.ShellCommandTask(
    name="extractNrrdVectorIndex",
    executable=" extractNrrdVectorIndex ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTensorVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTensorVolume %s",
                "help_string": "Required: input file containing the diffusion tensor image"
            }
        ),
    ),
    (
        "anisotropyType", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--anisotropyType %s",
                "help_string": "Anisotropy Mapping Type: ADC, FA, RA, VR, AD, RD, LI"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing the selected kind of anisotropy scalar."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing the selected kind of anisotropy scalar.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractAnisotropyMap_task = pydra.ShellCommandTask(
    name="gtractAnisotropyMap",
    executable=" gtractAnisotropyMap ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input image file name containing multiple baseline gradients to average"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing directly averaged baseline images"
            }
        ),
    ),
    (
        "directionsTolerance", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--directionsTolerance %f",
                "help_string": "Tolerance for matching identical gradient direction pairs"
            }
        ),
    ),
    (
        "averageB0only", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--averageB0only ",
                "help_string": "Average only baseline gradients. All other gradient directions are not averaged, but retained in the outputVolume"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing directly averaged baseline images",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractAverageBvalues_task = pydra.ShellCommandTask(
    name="gtractAverageBvalues",
    executable=" gtractAverageBvalues ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input image file name"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing the clipped anisotropy image"
            }
        ),
    ),
    (
        "clipFirstSlice", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--clipFirstSlice ",
                "help_string": "Clip the first slice of the anisotropy image"
            }
        ),
    ),
    (
        "clipLastSlice", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--clipLastSlice ",
                "help_string": "Clip the last slice of the anisotropy image"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing the clipped anisotropy image",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractClipAnisotropy_task = pydra.ShellCommandTask(
    name="gtractClipAnisotropy",
    executable=" gtractClipAnisotropy ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input vector image file name. It is recommended that the input volume is the skull stripped baseline image of the DWI scan."
            }
        ),
    ),
    (
        "inputAnatomicalVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnatomicalVolume %s",
                "help_string": "Required: input anatomical image file name. It is recommended that that the input anatomical image has been skull stripped and has the same orientation as the DWI scan."
            }
        ),
    ),
    (
        "vectorIndex", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--vectorIndex %d",
                "help_string": "Vector image index in the moving image (within the DWI) to be used for registration."
            }
        ),
    ),
    (
        "inputRigidTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputRigidTransform %s",
                "help_string": "Required (for B-Spline type co-registration): input rigid transform file name. Used as a starting point for the anatomical B-Spline registration."
            }
        ),
    ),
    (
        "outputTransformName", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTransformName %s",
                "help_string": "Required: filename for the  fit transform."
            }
        ),
    ),
    (
        "transformType", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--transformType %s",
                "help_string": "Transform Type: Rigid|Bspline"
            }
        ),
    ),
    (
        "numberOfIterations", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfIterations %d",
                "help_string": "Number of iterations in the selected 3D fit"
            }
        ),
    ),
    (
        "gridSize", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--gridSize %s",
                "help_string": "Number of grid subdivisions in all 3 directions"
            }
        ),
    ),
    (
        "borderSize", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--borderSize %d",
                "help_string": "Size of border"
            }
        ),
    ),
    (
        "numberOfHistogramBins", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfHistogramBins %d",
                "help_string": "Number of histogram bins"
            }
        ),
    ),
    (
        "spatialScale", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--spatialScale %d",
                "help_string": "Scales the number of voxels in the image by this value to specify the number of voxels used in the registration"
            }
        ),
    ),
    (
        "convergence", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--convergence %f",
                "help_string": "Convergence Factor"
            }
        ),
    ),
    (
        "gradientTolerance", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--gradientTolerance %f",
                "help_string": "Gradient Tolerance"
            }
        ),
    ),
    (
        "maxBSplineDisplacement", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maxBSplineDisplacement %f",
                "help_string": " Sets the maximum allowed displacements in image physical coordinates for BSpline control grid along each axis.  A value of 0.0 indicates that the problem should be unbounded.  NOTE:  This only constrains the BSpline portion, and does not limit the displacement from the associated bulk transform.  This can lead to a substantial reduction in computation time in the BSpline optimizer.,       "
            }
        ),
    ),
    (
        "maximumStepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumStepSize %f",
                "help_string": "Maximum permitted step size to move in the selected 3D fit"
            }
        ),
    ),
    (
        "minimumStepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--minimumStepSize %f",
                "help_string": "Minimum required step size to move in the selected 3D fit without converging -- decrease this to make the fit more exacting"
            }
        ),
    ),
    (
        "translationScale", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--translationScale %f",
                "help_string": "How much to scale up changes in position compared to unit rotational changes in radians -- decrease this to put more translation in the fit"
            }
        ),
    ),
    (
        "relaxationFactor", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--relaxationFactor %f",
                "help_string": "Fraction of gradient from Jacobian to attempt to move in the selected 3D fit"
            }
        ),
    ),
    (
        "numberOfSamples", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfSamples %d",
                "help_string": "The number of voxels sampled for mutual information computation.  Increase this for a slower, more careful fit. NOTE that it is suggested to use samplingPercentage instead of this option. However, if set, it overwrites the samplingPercentage option.  "
            }
        ),
    ),
    (
        "samplingPercentage", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--samplingPercentage %f",
                "help_string": "This is a number in (0.0,1.0] interval that shows the percentage of the input fixed image voxels that are sampled for mutual information computation.  Increase this for a slower, more careful fit. You can also limit the sampling focus with ROI masks and ROIAUTO mask generation. The default is to use approximately 5% of voxels (for backwards compatibility 5% ~= 500000/(256*256*256)). Typical values range from 1% for low detail images to 20% for high detail images."
            }
        ),
    ),
    (
        "useMomentsAlign", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useMomentsAlign ",
                "help_string": "MomentsAlign assumes that the center of mass of the images represent similar structures.  Perform a MomentsAlign registration as part of the sequential registration steps.   This option MUST come first, and CAN NOT be used with either CenterOfHeadLAlign, GeometryAlign, or initialTransform file.  This family of options superceeds the use of transformType if any of them are set."
            }
        ),
    ),
    (
        "useGeometryAlign", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useGeometryAlign ",
                "help_string": "GeometryAlign on assumes that the center of the voxel lattice of the images represent similar structures. Perform a GeometryCenterAlign registration as part of the sequential registration steps.   This option MUST come first, and CAN NOT be used with either MomentsAlign, CenterOfHeadAlign, or initialTransform file.  This family of options superceeds the use of transformType if any of them are set."
            }
        ),
    ),
    (
        "useCenterOfHeadAlign", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useCenterOfHeadAlign ",
                "help_string": "CenterOfHeadAlign attempts to find a hemisphere full of foreground voxels from the superior direction as an estimate of where the center of a head shape would be to drive a center of mass estimate.  Perform a CenterOfHeadAlign registration as part of the sequential registration steps.   This option MUST come first, and CAN NOT be used with either MomentsAlign, GeometryAlign, or initialTransform file.  This family of options superceeds the use of transformType if any of them are set."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputTransformName", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: filename for the  fit transform.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractCoRegAnatomy_task = pydra.ShellCommandTask(
    name="gtractCoRegAnatomy",
    executable=" gtractCoRegAnatomy ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input vector image file name. It is recommended that the input volume is the skull stripped baseline image of the DWI scan."
            }
        ),
    ),
    (
        "inputAnatomicalVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnatomicalVolume %s",
                "help_string": "Required: input anatomical image file name. It is recommended that that the input anatomical image has been skull stripped and has the same orientation as the DWI scan."
            }
        ),
    ),
    (
        "vectorIndex", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--vectorIndex %d",
                "help_string": "Vector image index in the moving image (within the DWI) to be used for registration."
            }
        ),
    ),
    (
        "inputRigidTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputRigidTransform %s",
                "help_string": "Required (for B-Spline type co-registration): input rigid transform file name. Used as a starting point for the anatomical B-Spline registration."
            }
        ),
    ),
    (
        "outputBsplineTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputBsplineTransform %s",
                "help_string": "Required: filename for the B-Spline fit transform."
            }
        ),
    ),
    (
        "numberOfIterations", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfIterations %d",
                "help_string": "Number of iterations in the selected 3D fit"
            }
        ),
    ),
    (
        "gridSize", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--gridSize %s",
                "help_string": "Number of grid subdivisions in all 3 directions"
            }
        ),
    ),
    (
        "borderSize", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--borderSize %d",
                "help_string": "Size of border"
            }
        ),
    ),
    (
        "numberOfHistogramBins", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfHistogramBins %d",
                "help_string": "Number of histogram bins"
            }
        ),
    ),
    (
        "spatialScale", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--spatialScale %d",
                "help_string": "Scales the number of voxels in the image by this value to specify the number of voxels used in the registration"
            }
        ),
    ),
    (
        "convergence", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--convergence %f",
                "help_string": "Convergence Factor"
            }
        ),
    ),
    (
        "gradientTolerance", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--gradientTolerance %f",
                "help_string": "Gradient Tolerance"
            }
        ),
    ),
    (
        "maxBSplineDisplacement", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maxBSplineDisplacement %f",
                "help_string": " Sets the maximum allowed displacements in image physical coordinates for BSpline control grid along each axis.  A value of 0.0 indicates that the problem should be unbounded.  NOTE:  This only constrains the BSpline portion, and does not limit the displacement from the associated bulk transform.  This can lead to a substantial reduction in computation time in the BSpline optimizer.,       "
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputBsplineTransform", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: filename for the B-Spline fit transform.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractCoRegAnatomyBspline_task = pydra.ShellCommandTask(
    name="gtractCoRegAnatomyBspline",
    executable=" gtractCoRegAnatomyBspline ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input vector image file name. It is recommended that the input volume is the skull stripped baseline image of the DWI scan."
            }
        ),
    ),
    (
        "inputAnatomicalVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnatomicalVolume %s",
                "help_string": "Required: input anatomical image file name. It is recommended that that the input anatomical image has been skull stripped and has the same orientation as the DWI scan."
            }
        ),
    ),
    (
        "vectorIndex", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--vectorIndex %d",
                "help_string": "Vector image index in the moving image (within the DWI) to be used for registration."
            }
        ),
    ),
    (
        "outputRigidTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputRigidTransform %s",
                "help_string": "Required: filename for the rigid fit transform."
            }
        ),
    ),
    (
        "numberOfIterations", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfIterations %d",
                "help_string": "Number of iterations in the selected 3D fit"
            }
        ),
    ),
    (
        "numberOfSamples", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfSamples %d",
                "help_string": "The number of voxels sampled for mutual information computation.  Increase this for a slower, more careful fit. NOTE that it is suggested to use samplingPercentage instead of this option. However, if set, it overwrites the samplingPercentage option.  "
            }
        ),
    ),
    (
        "samplingPercentage", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--samplingPercentage %f",
                "help_string": "This is a number in (0.0,1.0] interval that shows the percentage of the input fixed image voxels that are sampled for mutual information computation.  Increase this for a slower, more careful fit. You can also limit the sampling focus with ROI masks and ROIAUTO mask generation. The default is to use approximately 5% of voxels (for backwards compatibility 5% ~= 500000/(256*256*256)). Typical values range from 1% for low detail images to 20% for high detail images."
            }
        ),
    ),
    (
        "initialRotationAxis", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--initialRotationAxis %d",
                "help_string": "Axis for the initial rotation angle: 0, 1, 2 mean x, y, z, respectively."
            }
        ),
    ),
    (
        "initialRotationAngle", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--initialRotationAngle %f",
                "help_string": "Angle to rotate about the initial rotation angle (Degrees)"
            }
        ),
    ),
    (
        "relaxationFactor", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--relaxationFactor %f",
                "help_string": "Fraction of gradient from Jacobian to attempt to move in the selected 3D fit"
            }
        ),
    ),
    (
        "maximumStepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumStepSize %f",
                "help_string": "Maximum permitted step size to move in the selected 3D fit"
            }
        ),
    ),
    (
        "minimumStepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--minimumStepSize %f",
                "help_string": "Minimum required step size to move in the selected 3D fit without converging -- decrease this to make the fit more exacting"
            }
        ),
    ),
    (
        "spatialScale", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--spatialScale %f",
                "help_string": "How much to scale up changes in position compared to unit rotational changes in radians -- decrease this to put more translation in the fit"
            }
        ),
    ),
]

output_fields = [
    (
        "outputRigidTransform", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: filename for the rigid fit transform.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractCoRegAnatomyRigid_task = pydra.ShellCommandTask(
    name="gtractCoRegAnatomyRigid",
    executable=" gtractCoRegAnatomyRigid ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--inputVolume %s...",
                "help_string": "Required: input file containing the first diffusion weighted image"
            }
        ),
    ),
    (
        "ignoreOrigins", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--ignoreOrigins ",
                "help_string": "If image origins are different force all images to origin of first image"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing the combined diffusion weighted images."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing the combined diffusion weighted images.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractConcatDwi_task = pydra.ShellCommandTask(
    name="gtractConcatDwi",
    executable=" gtractConcatDwi ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input file containing the signed short image to reorient without resampling."
            }
        ),
    ),
    (
        "inputReferenceVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputReferenceVolume %s",
                "help_string": "Required: input file containing orietation that will be cloned."
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD or Nifti file containing the reoriented image in reference image space."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD or Nifti file containing the reoriented image in reference image space.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractCopyImageOrientation_task = pydra.ShellCommandTask(
    name="gtractCopyImageOrientation",
    executable=" gtractCopyImageOrientation ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "movingVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--movingVolume %s",
                "help_string": "Required: input moving image file name. In order to register gradients within a scan to its first gradient, set the movingVolume and fixedVolume as the same image."
            }
        ),
    ),
    (
        "fixedVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--fixedVolume %s",
                "help_string": "Required: input fixed image file name. It is recommended that this image should either contain or be a b0 image."
            }
        ),
    ),
    (
        "fixedVolumeIndex", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--fixedVolumeIndex %d",
                "help_string": "Index in the fixed image for registration. It is recommended that this image should be a b0 image."
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing moving images individually resampled and fit to the specified fixed image index."
            }
        ),
    ),
    (
        "outputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTransform %s",
                "help_string": "Registration 3D transforms concatenated in a single output file.  There are no tools that can use this, but can be used for debugging purposes."
            }
        ),
    ),
    (
        "eddyCurrentCorrection", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--eddyCurrentCorrection ",
                "help_string": "Flag to perform eddy current corection in addition to motion correction (recommended)"
            }
        ),
    ),
    (
        "numberOfIterations", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfIterations %d",
                "help_string": "Number of iterations in each 3D fit"
            }
        ),
    ),
    (
        "numberOfSpatialSamples", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfSpatialSamples %d",
                "help_string": "The number of voxels sampled for mutual information computation.  Increase this for a slower, more careful fit. NOTE that it is suggested to use samplingPercentage instead of this option. However, if set, it overwrites the samplingPercentage option.  "
            }
        ),
    ),
    (
        "samplingPercentage", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--samplingPercentage %f",
                "help_string": "This is a number in (0.0,1.0] interval that shows the percentage of the input fixed image voxels that are sampled for mutual information computation.  Increase this for a slower, more careful fit. You can also limit the sampling focus with ROI masks and ROIAUTO mask generation. The default is to use approximately 5% of voxels (for backwards compatibility 5% ~= 500000/(256*256*256)). Typical values range from 1% for low detail images to 20% for high detail images."
            }
        ),
    ),
    (
        "relaxationFactor", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--relaxationFactor %f",
                "help_string": "Fraction of gradient from Jacobian to attempt to move in each 3D fit step (adjust when eddyCurrentCorrection is enabled; suggested value = 0.25)"
            }
        ),
    ),
    (
        "maximumStepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumStepSize %f",
                "help_string": "Maximum permitted step size to move in each 3D fit step (adjust when eddyCurrentCorrection is enabled; suggested value = 0.1)"
            }
        ),
    ),
    (
        "minimumStepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--minimumStepSize %f",
                "help_string": "Minimum required step size to move in each 3D fit step without converging -- decrease this to make the fit more exacting"
            }
        ),
    ),
    (
        "spatialScale", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--spatialScale %f",
                "help_string": "How much to scale up changes in position compared to unit rotational changes in radians -- decrease this to put more rotation in the fit"
            }
        ),
    ),
    (
        "registerB0Only", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--registerB0Only ",
                "help_string": "Register the B0 images only"
            }
        ),
    ),
    (
        "debugLevel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--debugLevel %d",
                "help_string": "Display debug messages, and produce debug intermediate results.  0=OFF, 1=Minimal, 10=Maximum debugging."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing moving images individually resampled and fit to the specified fixed image index.",
                "exists": True
            }
        ),
    ),
    (
        "outputTransform", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Registration 3D transforms concatenated in a single output file.  There are no tools that can use this, but can be used for debugging purposes.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractCoregBvalues_task = pydra.ShellCommandTask(
    name="gtractCoregBvalues",
    executable=" gtractCoregBvalues ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTensorVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTensorVolume %s",
                "help_string": "Required: input tensor image file name"
            }
        ),
    ),
    (
        "inputAnisotropyVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnisotropyVolume %s",
                "help_string": "Required: input anisotropy image file name"
            }
        ),
    ),
    (
        "inputStartingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputStartingSeedsLabelMapVolume %s",
                "help_string": "Required: input starting seeds LabelMap image file name"
            }
        ),
    ),
    (
        "startingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--startingSeedsLabel %d",
                "help_string": "Label value for Starting Seeds"
            }
        ),
    ),
    (
        "outputCostVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputCostVolume %s",
                "help_string": "Output vcl_cost image"
            }
        ),
    ),
    (
        "outputSpeedVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputSpeedVolume %s",
                "help_string": "Output speed image"
            }
        ),
    ),
    (
        "anisotropyWeight", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--anisotropyWeight %f",
                "help_string": "Anisotropy weight used for vcl_cost function calculations"
            }
        ),
    ),
    (
        "stoppingValue", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--stoppingValue %f",
                "help_string": "Terminiating value for vcl_cost function estimation"
            }
        ),
    ),
    (
        "seedThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--seedThreshold %f",
                "help_string": "Anisotropy threshold used for seed selection"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputCostVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output vcl_cost image",
                "exists": True
            }
        ),
    ),
    (
        "outputSpeedVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output speed image",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractCostFastMarching_task = pydra.ShellCommandTask(
    name="gtractCostFastMarching",
    executable=" gtractCostFastMarching ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputFiber", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputFiber %s",
                "help_string": "Required: input fiber tract file name"
            }
        ),
    ),
    (
        "numberOfPoints", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfPoints %d",
                "help_string": "Number of points in output guide fiber"
            }
        ),
    ),
    (
        "outputFiber", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputFiber %s",
                "help_string": "Required: output guide fiber file name"
            }
        ),
    ),
    (
        "writeXMLPolyDataFile", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--writeXMLPolyDataFile ",
                "help_string": "Flag to make use of XML files when reading and writing vtkPolyData."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputFiber", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: output guide fiber file name",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractCreateGuideFiber_task = pydra.ShellCommandTask(
    name="gtractCreateGuideFiber",
    executable=" gtractCreateGuideFiber ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTensorVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTensorVolume %s",
                "help_string": "Required: input tensor image file name"
            }
        ),
    ),
    (
        "inputAnisotropyVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnisotropyVolume %s",
                "help_string": "Required: input anisotropy image file name"
            }
        ),
    ),
    (
        "inputCostVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputCostVolume %s",
                "help_string": "Required: input vcl_cost image file name"
            }
        ),
    ),
    (
        "inputStartingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputStartingSeedsLabelMapVolume %s",
                "help_string": "Required: input starting seeds LabelMap image file name"
            }
        ),
    ),
    (
        "startingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--startingSeedsLabel %d",
                "help_string": "Label value for Starting Seeds"
            }
        ),
    ),
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTract %s",
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them."
            }
        ),
    ),
    (
        "writeXMLPolyDataFile", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--writeXMLPolyDataFile ",
                "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts."
            }
        ),
    ),
    (
        "numberOfIterations", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfIterations %d",
                "help_string": "Number of iterations used for the optimization"
            }
        ),
    ),
    (
        "seedThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--seedThreshold %f",
                "help_string": "Anisotropy threshold used for seed selection"
            }
        ),
    ),
    (
        "trackingThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--trackingThreshold %f",
                "help_string": "Anisotropy threshold used for fiber tracking"
            }
        ),
    ),
    (
        "costStepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--costStepSize %f",
                "help_string": "Cost image sub-voxel sampling"
            }
        ),
    ),
    (
        "maximumStepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumStepSize %f",
                "help_string": "Maximum step size to move when tracking"
            }
        ),
    ),
    (
        "minimumStepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--minimumStepSize %f",
                "help_string": "Minimum step size to move when tracking"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractFastMarchingTracking_task = pydra.ShellCommandTask(
    name="gtractFastMarchingTracking",
    executable=" gtractFastMarchingTracking ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTensorVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTensorVolume %s",
                "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): input tensor image file name"
            }
        ),
    ),
    (
        "inputAnisotropyVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnisotropyVolume %s",
                "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): input anisotropy image file name"
            }
        ),
    ),
    (
        "inputStartingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputStartingSeedsLabelMapVolume %s",
                "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): input starting seeds LabelMap image file name"
            }
        ),
    ),
    (
        "startingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--startingSeedsLabel %d",
                "help_string": "Label value for Starting Seeds (required if Label number used to create seed point in Slicer was not 1)"
            }
        ),
    ),
    (
        "inputEndingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputEndingSeedsLabelMapVolume %s",
                "help_string": "Required (for Streamline, GraphSearch, and Guided fiber tracking methods): input ending seeds LabelMap image file name"
            }
        ),
    ),
    (
        "endingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--endingSeedsLabel %d",
                "help_string": "Label value for Ending Seeds (required if Label number used to create seed point in Slicer was not 1)"
            }
        ),
    ),
    (
        "inputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTract %s",
                "help_string": "Required (for Guided fiber tracking method): guide fiber in vtkPolydata file containing one tract line."
            }
        ),
    ),
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTract %s",
                "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): name of output vtkPolydata file containing tract lines and the point data collected along them."
            }
        ),
    ),
    (
        "writeXMLPolyDataFile", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--writeXMLPolyDataFile ",
                "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts."
            }
        ),
    ),
    (
        "trackingMethod", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--trackingMethod %s",
                "help_string": "Fiber tracking Filter Type: Guided|Free|Streamline|GraphSearch"
            }
        ),
    ),
    (
        "guidedCurvatureThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--guidedCurvatureThreshold %f",
                "help_string": "Guided Curvature Threshold (Degrees)"
            }
        ),
    ),
    (
        "maximumGuideDistance", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumGuideDistance %f",
                "help_string": "Maximum distance for using the guide fiber direction"
            }
        ),
    ),
    (
        "seedThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--seedThreshold %f",
                "help_string": "Anisotropy threshold for seed selection (recommended for Free fiber tracking)"
            }
        ),
    ),
    (
        "trackingThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--trackingThreshold %f",
                "help_string": "Anisotropy threshold for fiber tracking (anisotropy values of the next point along the path)"
            }
        ),
    ),
    (
        "curvatureThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--curvatureThreshold %f",
                "help_string": "Curvature threshold in degrees (recommended for Free  fiber tracking)"
            }
        ),
    ),
    (
        "branchingThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--branchingThreshold %f",
                "help_string": "Anisotropy Branching threshold (recommended for GraphSearch fiber tracking method)"
            }
        ),
    ),
    (
        "maximumBranchPoints", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--maximumBranchPoints %d",
                "help_string": "Maximum branch points (recommended for GraphSearch fiber tracking method)"
            }
        ),
    ),
    (
        "useRandomWalk", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useRandomWalk ",
                "help_string": "Flag to use random walk."
            }
        ),
    ),
    (
        "randomSeed", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--randomSeed %d",
                "help_string": "Random number generator seed"
            }
        ),
    ),
    (
        "branchingAngle", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--branchingAngle %f",
                "help_string": "Branching angle in degrees (recommended for GraphSearch fiber tracking method)"
            }
        ),
    ),
    (
        "minimumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--minimumLength %f",
                "help_string": "Minimum fiber length. Helpful for filtering invalid tracts."
            }
        ),
    ),
    (
        "maximumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumLength %f",
                "help_string": "Maximum fiber length (voxels)"
            }
        ),
    ),
    (
        "stepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--stepSize %f",
                "help_string": "Fiber tracking step size"
            }
        ),
    ),
    (
        "useLoopDetection", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useLoopDetection ",
                "help_string": "Flag to make use of loop detection."
            }
        ),
    ),
    (
        "useTend", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useTend ",
                "help_string": "Flag to make use of Tend F and Tend G parameters."
            }
        ),
    ),
    (
        "tendF", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendF %f",
                "help_string": "Tend F parameter"
            }
        ),
    ),
    (
        "tendG", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendG %f",
                "help_string": "Tend G parameter"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required (for Free, Streamline, GraphSearch, and Guided fiber tracking methods): name of output vtkPolydata file containing tract lines and the point data collected along them.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractFiberTracking_task = pydra.ShellCommandTask(
    name="gtractFiberTracking",
    executable=" gtractFiberTracking ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTensorVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTensorVolume %s",
                "help_string": "Required: input tensor image file name"
            }
        ),
    ),
    (
        "inputAnisotropyVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnisotropyVolume %s",
                "help_string": "Required: input anisotropy image file name"
            }
        ),
    ),
    (
        "inputStartingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputStartingSeedsLabelMapVolume %s",
                "help_string": "Required: input starting seeds LabelMap image file name"
            }
        ),
    ),
    (
        "startingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--startingSeedsLabel %d",
                "help_string": "Label value for Starting Seeds"
            }
        ),
    ),
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTract %s",
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them."
            }
        ),
    ),
    (
        "writeXMLPolyDataFile", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--writeXMLPolyDataFile ",
                "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts."
            }
        ),
    ),
    (
        "seedThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--seedThreshold %f",
                "help_string": "Anisotropy threshold for seed selection"
            }
        ),
    ),
    (
        "trackingThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--trackingThreshold %f",
                "help_string": "Anisotropy threshold for fiber tracking"
            }
        ),
    ),
    (
        "curvatureThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--curvatureThreshold %f",
                "help_string": "Curvature threshold (Degrees)"
            }
        ),
    ),
    (
        "minimumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--minimumLength %f",
                "help_string": "Minimum fiber length. Helpful for filtering invalid tracts."
            }
        ),
    ),
    (
        "maximumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumLength %f",
                "help_string": "Maximum fiber length"
            }
        ),
    ),
    (
        "stepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--stepSize %f",
                "help_string": "Fiber tracking step size"
            }
        ),
    ),
    (
        "useLoopDetection", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useLoopDetection ",
                "help_string": "Flag to make use of loop detection."
            }
        ),
    ),
    (
        "useTend", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useTend ",
                "help_string": "Flag to make use of Tend F and Tend G parameters."
            }
        ),
    ),
    (
        "tendF", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendF %f",
                "help_string": "Tend F parameter"
            }
        ),
    ),
    (
        "tendG", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendG %f",
                "help_string": "Tend G parameter"
            }
        ),
    ),
]

output_fields = [
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractFreeTracking_task = pydra.ShellCommandTask(
    name="gtractFreeTracking",
    executable=" gtractFreeTracking ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTensorVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTensorVolume %s",
                "help_string": "Required: input tensor image file name"
            }
        ),
    ),
    (
        "inputAnisotropyVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnisotropyVolume %s",
                "help_string": "Required: input anisotropy image file name"
            }
        ),
    ),
    (
        "inputStartingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputStartingSeedsLabelMapVolume %s",
                "help_string": "Required: input starting seeds LabelMap image file name"
            }
        ),
    ),
    (
        "startingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--startingSeedsLabel %d",
                "help_string": "Label value for Starting Seeds"
            }
        ),
    ),
    (
        "inputEndingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputEndingSeedsLabelMapVolume %s",
                "help_string": "Required: input ending seeds LabelMap image file name"
            }
        ),
    ),
    (
        "endingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--endingSeedsLabel %d",
                "help_string": "Label value for Ending Seeds"
            }
        ),
    ),
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTract %s",
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them."
            }
        ),
    ),
    (
        "writeXMLPolyDataFile", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--writeXMLPolyDataFile ",
                "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts."
            }
        ),
    ),
    (
        "seedThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--seedThreshold %f",
                "help_string": "Anisotropy threshold for seed selection"
            }
        ),
    ),
    (
        "trackingThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--trackingThreshold %f",
                "help_string": "Anisotropy threshold for fiber tracking"
            }
        ),
    ),
    (
        "curvatureThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--curvatureThreshold %f",
                "help_string": "Curvature threshold (Degrees)"
            }
        ),
    ),
    (
        "branchingThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--branchingThreshold %f",
                "help_string": "Anisotropy Branching threshold"
            }
        ),
    ),
    (
        "maximumBranchPoints", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--maximumBranchPoints %d",
                "help_string": "Maximum branch points"
            }
        ),
    ),
    (
        "useRandomWalk", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useRandomWalk ",
                "help_string": "Flag to use random walk."
            }
        ),
    ),
    (
        "randomSeed", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--randomSeed %d",
                "help_string": "Random number generator seed"
            }
        ),
    ),
    (
        "branchingAngle", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--branchingAngle %f",
                "help_string": "Branchging angle (Degrees)"
            }
        ),
    ),
    (
        "minimumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--minimumLength %f",
                "help_string": "Minimum fiber length. Helpful for filtering invalid tracts."
            }
        ),
    ),
    (
        "maximumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumLength %f",
                "help_string": "Maximum fiber length"
            }
        ),
    ),
    (
        "stepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--stepSize %f",
                "help_string": "Fiber tracking step size"
            }
        ),
    ),
    (
        "useLoopDetection", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useLoopDetection ",
                "help_string": "Flag to make use of loop detection."
            }
        ),
    ),
    (
        "useTend", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useTend ",
                "help_string": "Flag to make use of Tend F and Tend G parameters."
            }
        ),
    ),
    (
        "tendF", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendF %f",
                "help_string": "Tend F parameter"
            }
        ),
    ),
    (
        "tendG", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendG %f",
                "help_string": "Tend G parameter"
            }
        ),
    ),
]

output_fields = [
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractGraphSearchTracking_task = pydra.ShellCommandTask(
    name="gtractGraphSearchTracking",
    executable=" gtractGraphSearchTracking ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTensorVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTensorVolume %s",
                "help_string": "Required: input tensor image file name"
            }
        ),
    ),
    (
        "inputAnisotropyVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnisotropyVolume %s",
                "help_string": "Required: input anisotropy image file name"
            }
        ),
    ),
    (
        "inputStartingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputStartingSeedsLabelMapVolume %s",
                "help_string": "Required: input starting seeds LabelMap image file name"
            }
        ),
    ),
    (
        "startingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--startingSeedsLabel %d",
                "help_string": "Label value for Starting Seeds"
            }
        ),
    ),
    (
        "inputEndingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputEndingSeedsLabelMapVolume %s",
                "help_string": "Required: input ending seeds LabelMap image file name"
            }
        ),
    ),
    (
        "endingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--endingSeedsLabel %d",
                "help_string": "Label value for Ending Seeds"
            }
        ),
    ),
    (
        "inputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTract %s",
                "help_string": "Required: guide fiber in vtkPolydata file containing one tract line."
            }
        ),
    ),
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTract %s",
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them."
            }
        ),
    ),
    (
        "writeXMLPolyDataFile", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--writeXMLPolyDataFile ",
                "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts."
            }
        ),
    ),
    (
        "seedThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--seedThreshold %f",
                "help_string": "Anisotropy threshold for seed selection"
            }
        ),
    ),
    (
        "trackingThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--trackingThreshold %f",
                "help_string": "Anisotropy threshold for fiber tracking"
            }
        ),
    ),
    (
        "maximumGuideDistance", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumGuideDistance %f",
                "help_string": "Maximum distance for using the guide fiber direction"
            }
        ),
    ),
    (
        "curvatureThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--curvatureThreshold %f",
                "help_string": "Curvature threshold (Degrees)"
            }
        ),
    ),
    (
        "guidedCurvatureThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--guidedCurvatureThreshold %f",
                "help_string": "Guided Curvature Threshold (Degrees)"
            }
        ),
    ),
    (
        "minimumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--minimumLength %f",
                "help_string": "Minimum fiber length. Helpful for filtering invalid tracts."
            }
        ),
    ),
    (
        "maximumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumLength %f",
                "help_string": "Maximum fiber length"
            }
        ),
    ),
    (
        "stepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--stepSize %f",
                "help_string": "Fiber tracking step size"
            }
        ),
    ),
    (
        "useLoopDetection", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useLoopDetection ",
                "help_string": "Flag to make use of loop detection."
            }
        ),
    ),
    (
        "useTend", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useTend ",
                "help_string": "Flag to make use of Tend F and Tend G parameters."
            }
        ),
    ),
    (
        "tendF", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendF %f",
                "help_string": "Tend F parameter"
            }
        ),
    ),
    (
        "tendG", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendG %f",
                "help_string": "Tend G parameter"
            }
        ),
    ),
]

output_fields = [
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractGuidedTracking_task = pydra.ShellCommandTask(
    name="gtractGuidedTracking",
    executable=" gtractGuidedTracking ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input file containing the signed short image to reorient without resampling."
            }
        ),
    ),
    (
        "inputReferenceVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputReferenceVolume %s",
                "help_string": "Required: input file containing the standard image to clone the characteristics of."
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output Nrrd or Nifti file containing the reoriented image in reference image space."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output Nrrd or Nifti file containing the reoriented image in reference image space.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractImageConformity_task = pydra.ShellCommandTask(
    name="gtractImageConformity",
    executable=" gtractImageConformity ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputReferenceVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputReferenceVolume %s",
                "help_string": "Required: input image file name to exemplify the anatomical space to interpolate over."
            }
        ),
    ),
    (
        "inputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTransform %s",
                "help_string": "Required: input B-Spline transform file name"
            }
        ),
    ),
    (
        "outputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTransform %s",
                "help_string": "Required: output transform file name"
            }
        ),
    ),
    (
        "landmarkDensity", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--landmarkDensity %s",
                "help_string": "Number of landmark subdivisions in all 3 directions"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputTransform", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: output transform file name",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractInvertBSplineTransform_task = pydra.ShellCommandTask(
    name="gtractInvertBSplineTransform",
    executable=" gtractInvertBSplineTransform ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "baseImage", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--baseImage %s",
                "help_string": "Required: base image used to define the size of the inverse field"
            }
        ),
    ),
    (
        "deformationImage", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--deformationImage %s",
                "help_string": "Required: Displacement field image"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: Output deformation field"
            }
        ),
    ),
    (
        "subsamplingFactor", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--subsamplingFactor %d",
                "help_string": "Subsampling factor for the deformation field"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: Output deformation field",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractInvertDisplacementField_task = pydra.ShellCommandTask(
    name="gtractInvertDisplacementField",
    executable=" gtractInvertDisplacementField ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTransform %s",
                "help_string": "Required: input rigid transform file name"
            }
        ),
    ),
    (
        "outputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTransform %s",
                "help_string": "Required: output transform file name"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputTransform", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: output transform file name",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractInvertRigidTransform_task = pydra.ShellCommandTask(
    name="gtractInvertRigidTransform",
    executable=" gtractInvertRigidTransform ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputAnisotropyVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnisotropyVolume %s",
                "help_string": "Required: input file containing the anisotropy image"
            }
        ),
    ),
    (
        "inputAnatomicalVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnatomicalVolume %s",
                "help_string": "Required: input file containing the anatomical image whose characteristics will be cloned."
            }
        ),
    ),
    (
        "inputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTransform %s",
                "help_string": "Required: input Rigid OR Bspline transform file name"
            }
        ),
    ),
    (
        "transformType", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--transformType %s",
                "help_string": "Transform type: Rigid, B-Spline"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing the resampled transformed anisotropy image."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing the resampled transformed anisotropy image.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractResampleAnisotropy_task = pydra.ShellCommandTask(
    name="gtractResampleAnisotropy",
    executable=" gtractResampleAnisotropy ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input file containing the 4D image"
            }
        ),
    ),
    (
        "inputAnatomicalVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnatomicalVolume %s",
                "help_string": "Required: input file containing the anatomical image defining the origin, spacing and size of the resampled image (template)"
            }
        ),
    ),
    (
        "inputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTransform %s",
                "help_string": "Required: input Rigid OR Bspline transform file name"
            }
        ),
    ),
    (
        "vectorIndex", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--vectorIndex %d",
                "help_string": "Index in the diffusion weighted image set for the B0 image"
            }
        ),
    ),
    (
        "transformType", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--transformType %s",
                "help_string": "Transform type: Rigid, B-Spline"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing the resampled input image."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing the resampled input image.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractResampleB0_task = pydra.ShellCommandTask(
    name="gtractResampleB0",
    executable=" gtractResampleB0 ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputCodeVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputCodeVolume %s",
                "help_string": "Required: input file containing the code image"
            }
        ),
    ),
    (
        "inputReferenceVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputReferenceVolume %s",
                "help_string": "Required: input file containing the standard image to clone the characteristics of."
            }
        ),
    ),
    (
        "inputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTransform %s",
                "help_string": "Required: input Rigid or Inverse-B-Spline transform file name"
            }
        ),
    ),
    (
        "transformType", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--transformType %s",
                "help_string": "Transform type: Rigid or Inverse-B-Spline"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing the resampled code image in acquisition space."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing the resampled code image in acquisition space.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractResampleCodeImage_task = pydra.ShellCommandTask(
    name="gtractResampleCodeImage",
    executable=" gtractResampleCodeImage ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input image is a 4D NRRD image."
            }
        ),
    ),
    (
        "referenceVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--referenceVolume %s",
                "help_string": "If provided, resample to the final space of the referenceVolume 3D data set."
            }
        ),
    ),
    (
        "outputResampledB0", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputResampledB0 %s",
                "help_string": "Convenience function for extracting the first index location (assumed to be the B0)"
            }
        ),
    ),
    (
        "inputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTransform %s",
                "help_string": "Required: transform file derived from rigid registration of b0 image to reference structural image."
            }
        ),
    ),
    (
        "warpDWITransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--warpDWITransform %s",
                "help_string": "Optional: transform file to warp gradient volumes."
            }
        ),
    ),
    (
        "debugLevel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--debugLevel %d",
                "help_string": "Display debug messages, and produce debug intermediate results.  0=OFF, 1=Minimal, 10=Maximum debugging."
            }
        ),
    ),
    (
        "writeOutputMetaData", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--writeOutputMetaData %s",
                "help_string": "A file to write the output image diffusion gradient directions in a CSV file"
            }
        ),
    ),
    (
        "imageOutputSize", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--imageOutputSize %s",
                "help_string": "The voxel lattice for the output image, padding is added if necessary. NOTE: if 0,0,0, then the inputVolume size is used."
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: output image (NRRD file) that has been rigidly transformed into the space of the structural image and padded if image padding was changed from 0,0,0 default."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputResampledB0", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Convenience function for extracting the first index location (assumed to be the B0)",
                "exists": True
            }
        ),
    ),
    (
        "writeOutputMetaData", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "A file to write the output image diffusion gradient directions in a CSV file",
                "exists": True
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: output image (NRRD file) that has been rigidly transformed into the space of the structural image and padded if image padding was changed from 0,0,0 default.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractResampleDWIInPlace_task = pydra.ShellCommandTask(
    name="gtractResampleDWIInPlace",
    executable=" gtractResampleDWIInPlace ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputForwardDeformationFieldVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputForwardDeformationFieldVolume %s",
                "help_string": "Required: input forward deformation field image file name"
            }
        ),
    ),
    (
        "inputReverseDeformationFieldVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputReverseDeformationFieldVolume %s",
                "help_string": "Required: input reverse deformation field image file name"
            }
        ),
    ),
    (
        "inputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTract %s",
                "help_string": "Required: name of input vtkPolydata file containing tract lines."
            }
        ),
    ),
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTract %s",
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them."
            }
        ),
    ),
    (
        "writeXMLPolyDataFile", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--writeXMLPolyDataFile ",
                "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractResampleFibers_task = pydra.ShellCommandTask(
    name="gtractResampleFibers",
    executable=" gtractResampleFibers ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTensorVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTensorVolume %s",
                "help_string": "Required: input tensor image file name"
            }
        ),
    ),
    (
        "inputAnisotropyVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputAnisotropyVolume %s",
                "help_string": "Required: input anisotropy image file name"
            }
        ),
    ),
    (
        "inputStartingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputStartingSeedsLabelMapVolume %s",
                "help_string": "Required: input starting seeds LabelMap image file name"
            }
        ),
    ),
    (
        "startingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--startingSeedsLabel %d",
                "help_string": "Label value for Starting Seeds"
            }
        ),
    ),
    (
        "inputEndingSeedsLabelMapVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputEndingSeedsLabelMapVolume %s",
                "help_string": "Required: input ending seeds LabelMap image file name"
            }
        ),
    ),
    (
        "endingSeedsLabel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--endingSeedsLabel %d",
                "help_string": "Label value for Ending Seeds"
            }
        ),
    ),
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTract %s",
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them."
            }
        ),
    ),
    (
        "writeXMLPolyDataFile", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--writeXMLPolyDataFile ",
                "help_string": "Flag to make use of the XML format for vtkPolyData fiber tracts."
            }
        ),
    ),
    (
        "seedThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--seedThreshold %f",
                "help_string": "Anisotropy threshold for seed selection"
            }
        ),
    ),
    (
        "trackingThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--trackingThreshold %f",
                "help_string": "Anisotropy threshold for fiber tracking"
            }
        ),
    ),
    (
        "curvatureThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--curvatureThreshold %f",
                "help_string": "Curvature threshold (Degrees)"
            }
        ),
    ),
    (
        "minimumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--minimumLength %f",
                "help_string": "Minimum fiber length. Helpful for filtering invalid tracts."
            }
        ),
    ),
    (
        "maximumLength", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--maximumLength %f",
                "help_string": "Maximum fiber length"
            }
        ),
    ),
    (
        "stepSize", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--stepSize %f",
                "help_string": "Fiber tracking step size"
            }
        ),
    ),
    (
        "useLoopDetection", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useLoopDetection ",
                "help_string": "Flag to make use of loop detection."
            }
        ),
    ),
    (
        "useTend", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--useTend ",
                "help_string": "Flag to make use of Tend F and Tend G parameters."
            }
        ),
    ),
    (
        "tendF", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendF %f",
                "help_string": "Tend F parameter"
            }
        ),
    ),
    (
        "tendG", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--tendG %f",
                "help_string": "Tend G parameter"
            }
        ),
    ),
]

output_fields = [
    (
        "outputTract", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output vtkPolydata file containing tract lines and the point data collected along them.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractStreamlineTracking_task = pydra.ShellCommandTask(
    name="gtractStreamlineTracking",
    executable=" gtractStreamlineTracking ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input image 4D NRRD image. Must contain data based on at least 6 distinct diffusion directions. The inputVolume is allowed to have multiple b0 and gradient direction images. Averaging of the b0 image is done internally in this step. Prior averaging of the DWIs is not required."
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Required: name of output NRRD file containing the Tensor vector image"
            }
        ),
    ),
    (
        "medianFilterSize", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--medianFilterSize %s",
                "help_string": "Median filter radius in all 3 directions"
            }
        ),
    ),
    (
        "maskProcessingMode", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--maskProcessingMode %s",
                "help_string": "ROIAUTO:  mask is implicitly defined using a otsu forground and hole filling algorithm. ROI: Uses the masks to define what parts of the image should be used for computing the transform. NOMASK: no mask used"
            }
        ),
    ),
    (
        "maskVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--maskVolume %s",
                "help_string": "Mask Image, if maskProcessingMode is ROI"
            }
        ),
    ),
    (
        "backgroundSuppressingThreshold", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--backgroundSuppressingThreshold %d",
                "help_string": "Image threshold to suppress background. This sets a threshold used on the b0 image to remove background voxels from processing. Typically, values of 100 and 500 work well for Siemens and GE DTI data, respectively. Check your data particularly in the globus pallidus to make sure the brain tissue is not being eliminated with this threshold."
            }
        ),
    ),
    (
        "resampleIsotropic", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--resampleIsotropic ",
                "help_string": "Flag to resample to isotropic voxels. Enabling this feature is recommended if fiber tracking will be performed."
            }
        ),
    ),
    (
        "size", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--size %f",
                "help_string": "Isotropic voxel size to resample to"
            }
        ),
    ),
    (
        "b0Index", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--b0Index %d",
                "help_string": "Index in input vector index to extract"
            }
        ),
    ),
    (
        "applyMeasurementFrame", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--applyMeasurementFrame ",
                "help_string": "Flag to apply the measurement frame to the gradient directions"
            }
        ),
    ),
    (
        "ignoreIndex", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--ignoreIndex %s",
                "help_string": "Ignore diffusion gradient index. Used to remove specific gradient directions with artifacts."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Required: name of output NRRD file containing the Tensor vector image",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractTensor_task = pydra.ShellCommandTask(
    name="gtractTensor",
    executable=" gtractTensor ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTransform %s",
                "help_string": "Input Transform File Name"
            }
        ),
    ),
    (
        "inputReferenceVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputReferenceVolume %s",
                "help_string": "Required: input image file name to exemplify the anatomical space over which to vcl_express the transform as a displacement field."
            }
        ),
    ),
    (
        "outputDeformationFieldVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputDeformationFieldVolume %s",
                "help_string": "Output deformation field"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputDeformationFieldVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output deformation field",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

gtractTransformToDisplacementField_task = pydra.ShellCommandTask(
    name="gtractTransformToDisplacementField",
    executable=" gtractTransformToDisplacementField ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)