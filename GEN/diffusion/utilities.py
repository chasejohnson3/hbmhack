# -*- coding: utf-8 -*-
"""Autogenerated file - DO NOT EDIT
If you spot a bug, please report it on the mailing list and/or change the generator."""

import pydra
from pydra.engine import specs
import attr


input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Required: input image is a 4D NRRD image."
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "given a list of "
            }
        ),
    ),
    (
        "badGradients", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--badGradients %s"
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "given a list of ",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSDWICleanup_task = pydra.ShellCommandTask(
    name="BRAINSDWICleanup",
    executable=" BRAINSDWICleanup ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Input volume to be resampled",
                "position": -2
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Resampled Volume",
                "position": -1
            }
        ),
    ),
    (
        "Reference", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--Reference %s",
                "help_string": "Reference Volume (spacing,size,orientation,origin)"
            }
        ),
    ),
    (
        "transformationFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--transformationFile %s"
            }
        ),
    ),
    (
        "defField", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--defField %s",
                "help_string": "File containing the deformation field (3D vector image containing vectors with 3 components)"
            }
        ),
    ),
    (
        "hfieldtype", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--hfieldtype %s",
                "help_string": "Set if the deformation field is an -Field"
            }
        ),
    ),
    (
        "interpolation", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--interpolation %s",
                "help_string": "Sampling algorithm (linear , nn (nearest neighborhoor), ws (WindowedSinc), bs (BSpline) )"
            }
        ),
    ),
    (
        "noMeasurementFrame", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--noMeasurementFrame ",
                "help_string": "Do not use the measurement frame that is in the input image to transform the tensors. Uses the image orientation instead"
            }
        ),
    ),
    (
        "correction", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--correction %s",
                "help_string": "Correct the tensors if computed tensor is not semi-definite positive"
            }
        ),
    ),
    (
        "transform_tensor_method", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--transform_tensor_method %s",
                "help_string": "Chooses between 2 methods to transform the tensors: Finite Strain (FS), faster but less accurate, or Preservation of the Principal Direction (PPD)"
            }
        ),
    ),
    (
        "transform_order", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--transform_order %s",
                "help_string": "Select in what order the transforms are read"
            }
        ),
    ),
    (
        "notbulk", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--notbulk ",
                "help_string": "The transform following the BSpline transform is not set as a bulk transform for the BSpline transform"
            }
        ),
    ),
    (
        "spaceChange", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--spaceChange ",
                "help_string": "Space Orientation between transform and image is different (RAS/LPS) (warning: if the transform is a Transform Node in Slicer3, do not select)"
            }
        ),
    ),
    (
        "rotation_point", 
        attr.ib(
            type=traits.List,
            metadata={
                "argstr": "--rotation_point %s",
                "help_string": "Center of rotation (only for rigid and affine transforms)"
            }
        ),
    ),
    (
        "centered_transform", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--centered_transform ",
                "help_string": "Set the center of the transformation to the center of the input image (only for rigid and affine transforms)"
            }
        ),
    ),
    (
        "image_center", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--image_center %s",
                "help_string": "Image to use to center the transform (used only if \'Centered Transform\' is selected)"
            }
        ),
    ),
    (
        "Inverse_ITK_Transformation", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--Inverse_ITK_Transformation ",
                "help_string": "Inverse the transformation before applying it from output image to input image (only for rigid and affine transforms)"
            }
        ),
    ),
    (
        "spacing", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--spacing %s",
                "help_string": "Spacing along each dimension (0 means use input spacing)"
            }
        ),
    ),
    (
        "size", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--size %s",
                "help_string": "Size along each dimension (0 means use input size)"
            }
        ),
    ),
    (
        "origin", 
        attr.ib(
            type=traits.List,
            metadata={
                "argstr": "--origin %s",
                "help_string": "Origin of the output Image"
            }
        ),
    ),
    (
        "direction_matrix", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--direction_matrix %s",
                "help_string": "9 parameters of the direction matrix by rows (ijk to LPS if LPS transform, ijk to RAS if RAS transform)"
            }
        ),
    ),
    (
        "number_of_thread", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--number_of_thread %d",
                "help_string": "Number of thread used to compute the output image"
            }
        ),
    ),
    (
        "default_pixel_value", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--default_pixel_value %f",
                "help_string": "Default pixel value for samples falling outside of the input region"
            }
        ),
    ),
    (
        "window_function", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--window_function %s",
                "help_string": "Window Function \nh = Hamming \nc = Cosine \nw = Welch \nl = Lanczos \nb = Blackman"
            }
        ),
    ),
    (
        "spline_order", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--spline_order %d",
                "help_string": "Spline Order (Spline order may be from 0 to 5)"
            }
        ),
    ),
    (
        "transform_matrix", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--transform_matrix %s",
                "help_string": "12 parameters of the transform matrix by rows ( --last 3 being translation-- )"
            }
        ),
    ),
    (
        "transform", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--transform %s",
                "help_string": "Transform algorithm\nrt = Rigid Transform\na = Affine Transform"
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Resampled Volume",
                "position": -1,
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

ResampleDTIVolume_task = pydra.ShellCommandTask(
    name="ResampleDTIVolume",
    executable=" ResampleDTIVolume ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)