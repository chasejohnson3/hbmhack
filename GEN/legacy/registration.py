# -*- coding: utf-8 -*-
"""Autogenerated file - DO NOT EDIT
If you spot a bug, please report it on the mailing list and/or change the generator."""

import pydra
from pydra.engine import specs
import attr


input_fields = [
    (
        "fixedImage", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Image which defines the space into which the moving image is registered",
                "position": -2
            }
        ),
    ),
    (
        "movingImage", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "The transform goes from the fixed image's space into the moving image's space",
                "position": -1
            }
        ),
    ),
    (
        "resampledImage", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--resampledImage %s",
                "help_string": "Registration results"
            }
        ),
    ),
    (
        "loadTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--loadTransform %s",
                "help_string": "Load a transform that is immediately applied to the moving image"
            }
        ),
    ),
    (
        "saveTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--saveTransform %s",
                "help_string": "Save the transform that results from registration"
            }
        ),
    ),
    (
        "initialization", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--initialization %s",
                "help_string": "Method to prime the registration process"
            }
        ),
    ),
    (
        "registration", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--registration %s",
                "help_string": "Method for the registration process"
            }
        ),
    ),
    (
        "metric", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--metric %s",
                "help_string": "Method to quantify image match"
            }
        ),
    ),
    (
        "expectedOffset", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--expectedOffset %f",
                "help_string": "Expected misalignment after initialization"
            }
        ),
    ),
    (
        "expectedRotation", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--expectedRotation %f",
                "help_string": "Expected misalignment after initialization"
            }
        ),
    ),
    (
        "expectedScale", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--expectedScale %f",
                "help_string": "Expected misalignment after initialization"
            }
        ),
    ),
    (
        "expectedSkew", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--expectedSkew %f",
                "help_string": "Expected misalignment after initialization"
            }
        ),
    ),
    (
        "verbosityLevel", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--verbosityLevel %s",
                "help_string": "Level of detail of reporting progress"
            }
        ),
    ),
    (
        "sampleFromOverlap", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--sampleFromOverlap ",
                "help_string": "Limit metric evaluation to the fixed image region overlapped by the moving image"
            }
        ),
    ),
    (
        "fixedImageMask", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--fixedImageMask %s",
                "help_string": "Image which defines a mask for the fixed image"
            }
        ),
    ),
    (
        "randomNumberSeed", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--randomNumberSeed %d",
                "help_string": "Seed to generate a consistent random number sequence"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Number of CPU threads to use"
            }
        ),
    ),
    (
        "minimizeMemory", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--minimizeMemory ",
                "help_string": "Reduce the amount of memory required at the cost of increased computation time"
            }
        ),
    ),
    (
        "interpolation", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--interpolation %s",
                "help_string": "Method for interpolation within the optimization process"
            }
        ),
    ),
    (
        "fixedLandmarks", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--fixedLandmarks %s...",
                "help_string": "Ordered list of landmarks in the fixed image"
            }
        ),
    ),
    (
        "movingLandmarks", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--movingLandmarks %s...",
                "help_string": "Ordered list of landmarks in the moving image"
            }
        ),
    ),
    (
        "rigidMaxIterations", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--rigidMaxIterations %d",
                "help_string": "Maximum number of rigid optimization iterations"
            }
        ),
    ),
    (
        "rigidSamplingRatio", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--rigidSamplingRatio %f",
                "help_string": "Portion of the image to use in computing the metric during rigid registration"
            }
        ),
    ),
    (
        "affineMaxIterations", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--affineMaxIterations %d",
                "help_string": "Maximum number of affine optimization iterations"
            }
        ),
    ),
    (
        "affineSamplingRatio", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--affineSamplingRatio %f",
                "help_string": "Portion of the image to use in computing the metric during affine registration"
            }
        ),
    ),
    (
        "bsplineMaxIterations", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--bsplineMaxIterations %d",
                "help_string": "Maximum number of bspline optimization iterations"
            }
        ),
    ),
    (
        "bsplineSamplingRatio", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--bsplineSamplingRatio %f",
                "help_string": "Portion of the image to use in computing the metric during BSpline registration"
            }
        ),
    ),
    (
        "controlPointSpacing", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--controlPointSpacing %d",
                "help_string": "Number of pixels between control points"
            }
        ),
    ),
]

output_fields = [
    (
        "resampledImage", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Registration results",
                "exists": True
            }
        ),
    ),
    (
        "saveTransform", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Save the transform that results from registration",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

ExpertAutomatedRegistration_task = pydra.ShellCommandTask(
    name="ExpertAutomatedRegistration",
    executable=" ExpertAutomatedRegistration ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "gridSize", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--gridSize %d",
                "help_string": "Number of grid points on interior of image."
            }
        ),
    ),
    (
        "outputtransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputtransform %s",
                "help_string": "The grid transform (deformation vector field)."
            }
        ),
    ),
    (
        "FixedImageFileName", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Fixed image to which to register",
                "position": -2
            }
        ),
    ),
    (
        "MovingImageFileName", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "%s",
                "help_string": "Moving image",
                "position": -1
            }
        ),
    ),
]

output_fields = [
    (
        "outputtransform", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "The grid transform (deformation vector field).",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

TestGridTransformRegistration_task = pydra.ShellCommandTask(
    name="TestGridTransformRegistration",
    executable=" TestGridTransformRegistration ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)