# -*- coding: utf-8 -*-
"""Autogenerated file - DO NOT EDIT
If you spot a bug, please report it on the mailing list and/or change the generator."""

import pydra
from pydra.engine import specs
import attr


input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": ",         The Image to be resampled,       "
            }
        ),
    ),
    (
        "OutputresampleMSP", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--OutputresampleMSP %s",
                "help_string": ",         The image to be output.,       "
            }
        ),
    ),
    (
        "verbose", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--verbose ",
                "help_string": ",         Show more verbose output,       "
            }
        ),
    ),
    (
        "resultsDir", 
        attr.ib(
            type=Directory,
            metadata={
                "argstr": "--resultsDir %s",
                "help_string": ",         The directory for the results to be written.,       "
            }
        ),
    ),
    (
        "writedebuggingImagesLevel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--writedebuggingImagesLevel %d",
                "help_string": ",           This flag controls if debugging images are produced.  By default value of 0 is no images.  Anything greater than zero will be increasing level of debugging images.,       "
            }
        ),
    ),
    (
        "mspQualityLevel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--mspQualityLevel %d",
                "help_string": ",           Flag cotrols how agressive the MSP is estimated.  0=quick estimate (9 seconds), 1=normal estimate (11 seconds), 2=great estimate (22 seconds), 3=best estimate (58 seconds).,       "
            }
        ),
    ),
    (
        "rescaleIntensities", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--rescaleIntensities ",
                "help_string": ",           Flag to turn on rescaling image intensities on input.,       "
            }
        ),
    ),
    (
        "trimRescaledIntensities", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--trimRescaledIntensities %f",
                "help_string": ",           Turn on clipping the rescaled image one-tailed on input.  Units of standard deviations above the mean.  Very large values are very permissive.  Non-positive value turns clipping off.  Defaults to removing 0.00001 of a normal tail above the mean.,       "
            }
        ),
    ),
    (
        "rescaleIntensitiesOutputRange", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--rescaleIntensitiesOutputRange %s",
                "help_string": ",           This pair of integers gives the lower and upper bounds on the signal portion of the output image.  Out-of-field voxels are taken from BackgroundFillValue.,       "
            }
        ),
    ),
    (
        "BackgroundFillValue", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--BackgroundFillValue %s",
                "help_string": "Fill the background of image with specified short int value. Enter number or use BIGNEG for a large negative number."
            }
        ),
    ),
    (
        "interpolationMode", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--interpolationMode %s",
                "help_string": "Type of interpolation to be used when applying transform to moving volume.  Options are Linear, ResampleInPlace, NearestNeighbor, BSpline, or WindowedSinc"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "OutputresampleMSP", 
        attr.ib(
            type=File,
            metadata={
                "help_string": ",         The image to be output.,       ",
                "exists": True
            }
        ),
    ),
    (
        "resultsDir", 
        attr.ib(
            type=Directory,
            metadata={
                "help_string": ",         The directory for the results to be written.,       ",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSAlignMSP_task = pydra.ShellCommandTask(
    name="BRAINSAlignMSP",
    executable=" BRAINSAlignMSP ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Input image to make a clipped short int copy from."
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Output image, a short int copy of the upper portion of the input image, filled with BackgroundFillValue."
            }
        ),
    ),
    (
        "acLowerBound", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--acLowerBound %f",
                "help_string": ",                 When the input image to the output image, replace the image with the BackgroundFillValue everywhere below the plane This Far in physical units (millimeters) below (inferior to) the AC point (assumed to be the voxel field middle.)  The oversize default was chosen to have no effect.  Based on visualizing a thousand masks in the IPIG study, we recommend a limit no smaller than 80.0 mm.,             "
            }
        ),
    ),
    (
        "BackgroundFillValue", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--BackgroundFillValue %s",
                "help_string": "Fill the background of image with specified short int value. Enter number or use BIGNEG for a large negative number."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output image, a short int copy of the upper portion of the input image, filled with BackgroundFillValue.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSClipInferior_task = pydra.ShellCommandTask(
    name="BRAINSClipInferior",
    executable=" BRAINSClipInferior ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "The filename of the input NIfTI volume to view/manipulate"
            }
        ),
    ),
    (
        "inputLandmarks", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputLandmarks %s",
                "help_string": ",               The filename for the new subject-specific landmark definition file in the same format produced by Slicer3 (in a .fcsv format) with the landmarks in the original image space in it to be read in.,             "
            }
        ),
    ),
    (
        "outputLandmarks", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputLandmarks %s",
                "help_string": ",               The filename for the new subject-specific landmark definition file in the same format produced by Slicer3 (in a .fcsv format) with the landmarks in the original image space in it to be written.,             "
            }
        ),
    ),
]

output_fields = [
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))


BRAINSConstellationDetectorGUI_task = pydra.ShellCommandTask(
    name="BRAINSConstellationDetectorGUI",
    executable=" BRAINSConstellationDetectorGUI ", 
    input_spec=input_spec_pdr,
    
)

input_fields = [
    (
        "inputLandmarksFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputLandmarksFile %s",
                "help_string": "Input landmarks file (.fcsv)"
            }
        ),
    ),
    (
        "inputTransformFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTransformFile %s",
                "help_string": "input composite transform file (.h5,.hdf5)"
            }
        ),
    ),
    (
        "outputLandmarksFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputLandmarksFile %s",
                "help_string": "Output landmarks file (.fcsv)"
            }
        ),
    ),
]

output_fields = [
    (
        "outputLandmarksFile", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output landmarks file (.fcsv)",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSConstellationLandmarksTransform_task = pydra.ShellCommandTask(
    name="BRAINSConstellationLandmarksTransform",
    executable=" BRAINSConstellationLandmarksTransform ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "verbose", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--verbose ",
                "help_string": ",               Show more verbose output,             "
            }
        ),
    ),
    (
        "inputTrainingList", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTrainingList %s",
                "help_string": ",               Setup file, giving all parameters for training up a template model for each landmark.,             "
            }
        ),
    ),
    (
        "outputModel", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputModel %s",
                "help_string": ",               The full filename of the output model file.,             "
            }
        ),
    ),
    (
        "saveOptimizedLandmarks", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--saveOptimizedLandmarks ",
                "help_string": ",               Flag to make a new subject-specific landmark definition file in the same format produced by Slicer3 with the optimized landmark (the detected RP, AC, and PC) in it.  Useful to tighten the variances in the ConstellationModeler.,             "
            }
        ),
    ),
    (
        "optimizedLandmarksFilenameExtender", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--optimizedLandmarksFilenameExtender %s",
                "help_string": ",                If the trainingList is (indexFullPathName) and contains landmark data filenames [path]/[filename].fcsv ,  make the optimized landmarks filenames out of [path]/[filename](thisExtender) and the optimized version of the input trainingList out of (indexFullPathName)(thisExtender) , when you rewrite all the landmarks according to the saveOptimizedLandmarks flag.,             "
            }
        ),
    ),
    (
        "resultsDir", 
        attr.ib(
            type=Directory,
            metadata={
                "argstr": "--resultsDir %s",
                "help_string": ",               The directory for the results to be written.,             "
            }
        ),
    ),
    (
        "mspQualityLevel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--mspQualityLevel %d",
                "help_string": ",                 Flag cotrols how agressive the MSP is estimated.  0=quick estimate (9 seconds), 1=normal estimate (11 seconds), 2=great estimate (22 seconds), 3=best estimate (58 seconds).,             "
            }
        ),
    ),
    (
        "rescaleIntensities", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--rescaleIntensities ",
                "help_string": ",                 Flag to turn on rescaling image intensities on input.,             "
            }
        ),
    ),
    (
        "trimRescaledIntensities", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--trimRescaledIntensities %f",
                "help_string": ",                 Turn on clipping the rescaled image one-tailed on input.  Units of standard deviations above the mean.  Very large values are very permissive.  Non-positive value turns clipping off.  Defaults to removing 0.00001 of a normal tail above the mean.,             "
            }
        ),
    ),
    (
        "rescaleIntensitiesOutputRange", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--rescaleIntensitiesOutputRange %s",
                "help_string": ",                 This pair of integers gives the lower and upper bounds on the signal portion of the output image.  Out-of-field voxels are taken from BackgroundFillValue.,             "
            }
        ),
    ),
    (
        "BackgroundFillValue", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--BackgroundFillValue %s",
                "help_string": "Fill the background of image with specified short int value. Enter number or use BIGNEG for a large negative number."
            }
        ),
    ),
    (
        "writedebuggingImagesLevel", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--writedebuggingImagesLevel %d",
                "help_string": ",                 This flag controls if debugging images are produced.  By default value of 0 is no images.  Anything greater than zero will be increasing level of debugging images.,             "
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputModel", 
        attr.ib(
            type=File,
            metadata={
                "help_string": ",               The full filename of the output model file.,             ",
                "exists": True
            }
        ),
    ),
    (
        "resultsDir", 
        attr.ib(
            type=Directory,
            metadata={
                "help_string": ",               The directory for the results to be written.,             ",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSConstellationModeler_task = pydra.ShellCommandTask(
    name="BRAINSConstellationModeler",
    executable=" BRAINSConstellationModeler ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "The input volume"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "The output volume"
            }
        ),
    ),
    (
        "debugDir", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--debugDir %s",
                "help_string": "A place for debug information"
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "The output volume",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSEyeDetector_task = pydra.ShellCommandTask(
    name="BRAINSEyeDetector",
    executable=" BRAINSEyeDetector ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Input Volume"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Output Volume"
            }
        ),
    ),
    (
        "splineGridSize", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--splineGridSize %s",
                "help_string": "The number of subdivisions of the BSpline Grid to be centered on the image space.  Each dimension must have at least 3 subdivisions for the BSpline to be correctly computed. "
            }
        ),
    ),
    (
        "permuteOrder", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--permuteOrder %s",
                "help_string": "The permutation order for the images.  The default is 0,1,2 (i.e. no permutation)"
            }
        ),
    ),
    (
        "outputLandmarksFile", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--outputLandmarksFile %s",
                "help_string": "Output filename"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output Volume",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSInitializedControlPoints_task = pydra.ShellCommandTask(
    name="BRAINSInitializedControlPoints",
    executable=" BRAINSInitializedControlPoints ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputFixedLandmarkFilename", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputFixedLandmarkFilename %s",
                "help_string": "input landmarks from fixed image *.fcsv"
            }
        ),
    ),
    (
        "inputMovingLandmarkFilename", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputMovingLandmarkFilename %s",
                "help_string": "input landmarks from moving image *.fcsv"
            }
        ),
    ),
    (
        "inputWeightFilename", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputWeightFilename %s",
                "help_string": "Input weight file name for landmarks. Higher weighted landmark will be considered more heavily. Weights are propotional, that is the magnitude of weights will be normalized by its minimum and maximum value. "
            }
        ),
    ),
    (
        "outputTransformFilename", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTransformFilename %s",
                "help_string": "output transform file name (ex: ./moving2fixed.h5) that is appropriate for applying to the moving image to align with the fixed image.  The _Inverse file is also written that is approporate for placing the moving Landmarks with the fixed image. "
            }
        ),
    ),
    (
        "outputTransformType", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--outputTransformType %s",
                "help_string": "The target transformation type. "
            }
        ),
    ),
    (
        "inputReferenceImageFilename", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputReferenceImageFilename %s",
                "help_string": "Set the reference image to define the parametric domain for the BSpline transform. "
            }
        ),
    ),
    (
        "bsplineNumberOfControlPoints", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--bsplineNumberOfControlPoints %d",
                "help_string": "Set the number of control points to define the parametric domain for the BSpline transform. "
            }
        ),
    ),
]

output_fields = [
    (
        "outputTransformFilename", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "output transform file name (ex: ./moving2fixed.h5) that is appropriate for applying to the moving image to align with the fixed image.  The _Inverse file is also written that is approporate for placing the moving Landmarks with the fixed image. ",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSLandmarkInitializer_task = pydra.ShellCommandTask(
    name="BRAINSLandmarkInitializer",
    executable=" BRAINSLandmarkInitializer ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTrainingList", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTrainingList %s",
                "help_string": "Input Training Landmark List Filename,             "
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))


BRAINSLinearModelerEPCA_task = pydra.ShellCommandTask(
    name="BRAINSLinearModelerEPCA",
    executable=" BRAINSLinearModelerEPCA ", 
    input_spec=input_spec_pdr,
    
)

input_fields = [
    (
        "inputMovingLandmarks", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputMovingLandmarks %s",
                "help_string": "Input Moving Landmark list file in fcsv,             "
            }
        ),
    ),
    (
        "inputFixedLandmarks", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputFixedLandmarks %s",
                "help_string": "Input Fixed Landmark list file in fcsv,             "
            }
        ),
    ),
    (
        "outputAffineTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputAffineTransform %s",
                "help_string": "The filename for the estimated affine transform,             "
            }
        ),
    ),
    (
        "inputMovingVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputMovingVolume %s",
                "help_string": "The filename of input moving volume"
            }
        ),
    ),
    (
        "inputReferenceVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputReferenceVolume %s",
                "help_string": "The filename of the reference volume"
            }
        ),
    ),
    (
        "outputResampledVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputResampledVolume %s",
                "help_string": "The filename of the output resampled volume"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputAffineTransform", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "The filename for the estimated affine transform,             ",
                "exists": True
            }
        ),
    ),
    (
        "outputResampledVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "The filename of the output resampled volume",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSLmkTransform_task = pydra.ShellCommandTask(
    name="BRAINSLmkTransform",
    executable=" BRAINSLmkTransform ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolumes", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--inputVolumes %s...",
                "help_string": "The input image volumes for finding the largest region filled mask."
            }
        ),
    ),
    (
        "inputMaskVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputMaskVolume %s",
                "help_string": "The ROI for region to compute histogram levels."
            }
        ),
    ),
    (
        "outputROIMaskVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputROIMaskVolume %s",
                "help_string": "The ROI automatically found from the input image."
            }
        ),
    ),
    (
        "outputClippedVolumeROI", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputClippedVolumeROI %s",
                "help_string": "The inputVolume clipped to the region of the brain mask."
            }
        ),
    ),
    (
        "lowerThreshold", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--lowerThreshold %s",
                "help_string": "Lower thresholds on the valid histogram regions for each modality"
            }
        ),
    ),
    (
        "upperThreshold", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--upperThreshold %s",
                "help_string": "Upper thresholds on the valid histogram regions for each modality"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputROIMaskVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "The ROI automatically found from the input image.",
                "exists": True
            }
        ),
    ),
    (
        "outputClippedVolumeROI", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "The inputVolume clipped to the region of the brain mask.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSMultiModeSegment_task = pydra.ShellCommandTask(
    name="BRAINSMultiModeSegment",
    executable=" BRAINSMultiModeSegment ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputFirstVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputFirstVolume %s",
                "help_string": "Input image (1) for mixture optimization"
            }
        ),
    ),
    (
        "inputSecondVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputSecondVolume %s",
                "help_string": "Input image (2) for mixture optimization"
            }
        ),
    ),
    (
        "inputMaskVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputMaskVolume %s",
                "help_string": "Input label image for mixture optimization"
            }
        ),
    ),
    (
        "outputWeightsFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputWeightsFile %s",
                "help_string": "Output Weights File"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "The MUSH image produced from the T1 and T2 weighted images"
            }
        ),
    ),
    (
        "outputMask", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputMask %s",
                "help_string": "The brain volume mask generated from the MUSH image"
            }
        ),
    ),
    (
        "seed", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--seed %s",
                "help_string": "Seed Point for Brain Region Filling"
            }
        ),
    ),
    (
        "desiredMean", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--desiredMean %f",
                "help_string": "Desired mean within the mask for weighted sum of both images."
            }
        ),
    ),
    (
        "desiredVariance", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--desiredVariance %f",
                "help_string": "Desired variance within the mask for weighted sum of both images."
            }
        ),
    ),
    (
        "lowerThresholdFactorPre", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--lowerThresholdFactorPre %f",
                "help_string": "Lower threshold factor for finding an initial brain mask"
            }
        ),
    ),
    (
        "upperThresholdFactorPre", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--upperThresholdFactorPre %f",
                "help_string": "Upper threshold factor for finding an initial brain mask"
            }
        ),
    ),
    (
        "lowerThresholdFactor", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--lowerThresholdFactor %f",
                "help_string": "Lower threshold factor for defining the brain mask"
            }
        ),
    ),
    (
        "upperThresholdFactor", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--upperThresholdFactor %f",
                "help_string": "Upper threshold factor for defining the brain mask"
            }
        ),
    ),
    (
        "boundingBoxSize", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--boundingBoxSize %s",
                "help_string": "Size of the cubic bounding box mask used when no brain mask is present"
            }
        ),
    ),
    (
        "boundingBoxStart", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--boundingBoxStart %s",
                "help_string": "XYZ point-coordinate for the start of the cubic bounding box mask used when no brain mask is present"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputWeightsFile", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output Weights File",
                "exists": True
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "The MUSH image produced from the T1 and T2 weighted images",
                "exists": True
            }
        ),
    ),
    (
        "outputMask", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "The brain volume mask generated from the MUSH image",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSMush_task = pydra.ShellCommandTask(
    name="BRAINSMush",
    executable=" BRAINSMush ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolumes", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--inputVolumes %s...",
                "help_string": "Input image volume list to be extracted as 2D image. Multiple input is possible. At least one input is required."
            }
        ),
    ),
    (
        "inputBinaryVolumes", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--inputBinaryVolumes %s...",
                "help_string": "Input mask (binary) volume list to be extracted as 2D image. Multiple input is possible."
            }
        ),
    ),
    (
        "inputSliceToExtractInPhysicalPoint", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--inputSliceToExtractInPhysicalPoint %s",
                "help_string": "2D slice number of input images. For autoWorkUp output, which AC-PC aligned, 0,0,0 will be the center."
            }
        ),
    ),
    (
        "inputSliceToExtractInIndex", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--inputSliceToExtractInIndex %s",
                "help_string": "2D slice number of input images. For size of 256*256*256 image, 128 is usually used."
            }
        ),
    ),
    (
        "inputSliceToExtractInPercent", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--inputSliceToExtractInPercent %s",
                "help_string": "2D slice number of input images. Percentage input from 0%-100%. (ex. --inputSliceToExtractInPercent 50,50,50"
            }
        ),
    ),
    (
        "inputPlaneDirection", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--inputPlaneDirection %s",
                "help_string": "Plane to display. In general, 0=saggital, 1=coronal, and 2=axial plane."
            }
        ),
    ),
    (
        "outputFilename", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputFilename %s",
                "help_string": "2D file name of input images. Required."
            }
        ),
    ),
]

output_fields = [
    (
        "outputFilename", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "2D file name of input images. Required.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSSnapShotWriter_task = pydra.ShellCommandTask(
    name="BRAINSSnapShotWriter",
    executable=" BRAINSSnapShotWriter ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTransform %s"
            }
        ),
    ),
    (
        "referenceVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--referenceVolume %s"
            }
        ),
    ),
    (
        "outputTransformType", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--outputTransformType %s",
                "help_string": "The target transformation type. Must be conversion-compatible with the input transform type"
            }
        ),
    ),
    (
        "outputPrecisionType", 
        attr.ib(
            type=traits.Enum,
            metadata={
                "argstr": "--outputPrecisionType %s",
                "help_string": "Precision type of the output transform. It can be either single precision or double precision"
            }
        ),
    ),
    (
        "displacementVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--displacementVolume %s"
            }
        ),
    ),
    (
        "outputTransform", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputTransform %s"
            }
        ),
    ),
]

output_fields = [
    (
        "displacementVolume", 
        attr.ib(
            type=File,
            metadata={
                "exists": True
            }
        ),
    ),
    (
        "outputTransform", 
        attr.ib(
            type=File,
            metadata={
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSTransformConvert_task = pydra.ShellCommandTask(
    name="BRAINSTransformConvert",
    executable=" BRAINSTransformConvert ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "Input image to trim off the neck (and also air-filling noise.)"
            }
        ),
    ),
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputVolume %s",
                "help_string": "Output image with neck and air-filling noise trimmed isotropic image with AC at center of image."
            }
        ),
    ),
    (
        "directionCode", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--directionCode %d",
                "help_string": ",                 This flag chooses which dimension to compare.  The sign lets you flip direction.,             "
            }
        ),
    ),
    (
        "otsuPercentileThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--otsuPercentileThreshold %f",
                "help_string": ",                 This is a parameter to FindLargestForegroundFilledMask, which is employed to trim off air-filling noise.,             "
            }
        ),
    ),
    (
        "closingSize", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--closingSize %d",
                "help_string": ",                 This is a parameter to FindLargestForegroundFilledMask,             "
            }
        ),
    ),
    (
        "headSizeLimit", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--headSizeLimit %f",
                "help_string": ",                 Use this to vary from the command line our search for how much upper tissue is head for the center-of-mass calculation.  Units are CCs, not cubic millimeters.,             "
            }
        ),
    ),
    (
        "BackgroundFillValue", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--BackgroundFillValue %s",
                "help_string": "Fill the background of image with specified short int value. Enter number or use BIGNEG for a large negative number."
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output image with neck and air-filling noise trimmed isotropic image with AC at center of image.",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

BRAINSTrimForegroundInDirection_task = pydra.ShellCommandTask(
    name="BRAINSTrimForegroundInDirection",
    executable=" BRAINSTrimForegroundInDirection ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputVolume %s",
                "help_string": "The image in which to find the center."
            }
        ),
    ),
    (
        "imageMask", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--imageMask %s"
            }
        ),
    ),
    (
        "clippedImageMask", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--clippedImageMask %s"
            }
        ),
    ),
    (
        "maximize", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--maximize "
            }
        ),
    ),
    (
        "axis", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--axis %d"
            }
        ),
    ),
    (
        "otsuPercentileThreshold", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--otsuPercentileThreshold %f"
            }
        ),
    ),
    (
        "closingSize", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--closingSize %d"
            }
        ),
    ),
    (
        "headSizeLimit", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--headSizeLimit %f"
            }
        ),
    ),
    (
        "headSizeEstimate", 
        attr.ib(
            type=traits.Float,
            metadata={
                "argstr": "--headSizeEstimate %f"
            }
        ),
    ),
    (
        "backgroundValue", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--backgroundValue %d"
            }
        ),
    ),
    (
        "generateDebugImages", 
        attr.ib(
            type=traits.Bool,
            metadata={
                "argstr": "--generateDebugImages "
            }
        ),
    ),
    (
        "debugDistanceImage", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--debugDistanceImage %s"
            }
        ),
    ),
    (
        "debugGridImage", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--debugGridImage %s"
            }
        ),
    ),
    (
        "debugAfterGridComputationsForegroundImage", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--debugAfterGridComputationsForegroundImage %s"
            }
        ),
    ),
    (
        "debugClippedImageMask", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--debugClippedImageMask %s"
            }
        ),
    ),
    (
        "debugTrimmedImage", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--debugTrimmedImage %s"
            }
        ),
    ),
]

output_fields = [
    (
        "clippedImageMask", 
        attr.ib(
            type=File,
            metadata={
                "exists": True
            }
        ),
    ),
    (
        "debugDistanceImage", 
        attr.ib(
            type=File,
            metadata={
                "exists": True
            }
        ),
    ),
    (
        "debugGridImage", 
        attr.ib(
            type=File,
            metadata={
                "exists": True
            }
        ),
    ),
    (
        "debugAfterGridComputationsForegroundImage", 
        attr.ib(
            type=File,
            metadata={
                "exists": True
            }
        ),
    ),
    (
        "debugClippedImageMask", 
        attr.ib(
            type=File,
            metadata={
                "exists": True
            }
        ),
    ),
    (
        "debugTrimmedImage", 
        attr.ib(
            type=File,
            metadata={
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

FindCenterOfBrain_task = pydra.ShellCommandTask(
    name="FindCenterOfBrain",
    executable=" FindCenterOfBrain ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputVolumes", 
        attr.ib(
            type=InputMultiPath,
            metadata={
                "argstr": "--inputVolumes %s...",
                "help_string": "The Input probaiblity images to be computed for lable maps"
            }
        ),
    ),
    (
        "outputLabelVolume", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputLabelVolume %s",
                "help_string": "The Input binary image for region of interest"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "outputLabelVolume", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "The Input binary image for region of interest",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

GenerateLabelMapFromProbabilityMap_task = pydra.ShellCommandTask(
    name="GenerateLabelMapFromProbabilityMap",
    executable=" GenerateLabelMapFromProbabilityMap ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "versionID", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--versionID %s",
                "help_string": ",         Current version ID. It should be match with the version of BCD that will be using the output model file,       "
            }
        ),
    ),
    (
        "landmarksInformationFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--landmarksInformationFile %s",
                "help_string": ",         name of HDF5 file to write matrices into,       "
            }
        ),
    ),
    (
        "landmarkTypesList", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--landmarkTypesList %s",
                "help_string": ",         file containing list of landmark types,       "
            }
        ),
    ),
    (
        "modelFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--modelFile %s",
                "help_string": ",         name of HDF5 file containing BRAINSConstellationDetector Model file (LLSMatrices, LLSMeans and LLSSearchRadii),       "
            }
        ),
    ),
    (
        "landmarkGlobPattern", 
        attr.ib(
            type=traits.Str,
            metadata={
                "argstr": "--landmarkGlobPattern %s",
                "help_string": "Glob pattern to select fcsv files"
            }
        ),
    ),
    (
        "numberOfThreads", 
        attr.ib(
            type=traits.Int,
            metadata={
                "argstr": "--numberOfThreads %d",
                "help_string": "Explicitly specify the maximum number of threads to use."
            }
        ),
    ),
]

output_fields = [
    (
        "landmarksInformationFile", 
        attr.ib(
            type=File,
            metadata={
                "help_string": ",         name of HDF5 file to write matrices into,       ",
                "exists": True
            }
        ),
    ),
    (
        "modelFile", 
        attr.ib(
            type=File,
            metadata={
                "help_string": ",         name of HDF5 file containing BRAINSConstellationDetector Model file (LLSMatrices, LLSMeans and LLSSearchRadii),       ",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

fcsv_to_hdf5_task = pydra.ShellCommandTask(
    name="fcsv_to_hdf5",
    executable=" fcsv_to_hdf5 ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputLandmarkFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputLandmarkFile %s",
                "help_string": "Input landmark file (.fcsv)"
            }
        ),
    ),
    (
        "outputLandmarkFile", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputLandmarkFile %s",
                "help_string": "Output landmark file (.fcsv)"
            }
        ),
    ),
]

output_fields = [
    (
        "outputLandmarkFile", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output landmark file (.fcsv)",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

insertMidACPCpoint_task = pydra.ShellCommandTask(
    name="insertMidACPCpoint",
    executable=" insertMidACPCpoint ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputLandmarksPaired", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputLandmarksPaired %s",
                "help_string": "Input landmark file (.fcsv)"
            }
        ),
    ),
    (
        "outputLandmarksPaired", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputLandmarksPaired %s",
                "help_string": "Output landmark file (.fcsv)"
            }
        ),
    ),
]

output_fields = [
    (
        "outputLandmarksPaired", 
        attr.ib(
            type=File,
            metadata={
                "help_string": "Output landmark file (.fcsv)",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

landmarksConstellationAligner_task = pydra.ShellCommandTask(
    name="landmarksConstellationAligner",
    executable=" landmarksConstellationAligner ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)

input_fields = [
    (
        "inputTrainingList", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTrainingList %s",
                "help_string": ",                 Setup file, giving all parameters for training up a Weight list for landmark.,             "
            }
        ),
    ),
    (
        "inputTemplateModel", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--inputTemplateModel %s",
                "help_string": "User-specified template model.,             "
            }
        ),
    ),
    (
        "LLSModel", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--LLSModel %s",
                "help_string": "Linear least squares model filename in HD5 format"
            }
        ),
    ),
    (
        "outputWeightsList", 
        attr.ib(
            type=File,
            metadata={
                "argstr": "--outputWeightsList %s",
                "help_string": ",                 The filename of a csv file which is a list of landmarks and their corresponding weights.,             "
            }
        ),
    ),
]

output_fields = [
    (
        "outputWeightsList", 
        attr.ib(
            type=File,
            metadata={
                "help_string": ",                 The filename of a csv file which is a list of landmarks and their corresponding weights.,             ",
                "exists": True
            }
        ),
    ),
]

input_spec_pdr = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))
output_spec_pdr = specs.SpecInfo(name="Output", fields=output_fields, bases=(specs.ShellSpec,))

landmarksConstellationWeights_task = pydra.ShellCommandTask(
    name="landmarksConstellationWeights",
    executable=" landmarksConstellationWeights ", 
    input_spec=input_spec_pdr,
    output_spec=output_spec_pdr
)